"""
Comprehensive Visual Content Injection

Injects all three types of visual content into webapp JSON:
1. Question Diagrams: Adds diagram reference to question text
2. Choice Diagrams: Adds choiceImage field, updates options to letters
3. Fill-in-the-Blanks: Adds compositeImage field, updates options to letters

Uses the mapping file generated by validate_visual_content.py
"""

import json
from pathlib import Path
from typing import Dict, List


def extract_question_number(question: Dict) -> str:
    """
    Extract question number from either 'number' field or 'id' field.
    Handles formats like: {"number": 10} or {"id": "2025_FE-A_10"}
    """
    if "number" in question:
        return str(question["number"])
    
    # Extract from ID format: "2025_FE-A_10" -> "10"
    q_id = question.get("id", "")
    if "_" in q_id:
        # Split by underscore and get last part (question number)
        return q_id.split("_")[-1]
    
    return str(q_id)


def inject_question_diagrams(questions: List[Dict], mapping: Dict) -> tuple[List[Dict], int]:
    """
    Inject standard question diagram references.
    Prepends ![Image](path) to question text if not already present.
    """
    updated_count = 0
    question_map = mapping.get("questions", {})
    
    for question in questions:
        q_num_str = extract_question_number(question)
        
        if q_num_str in question_map:
            web_path = question_map[q_num_str]["web_path"]
            image_ref = f"![Image]({web_path})"
            
            # Check if already injected (handle both "text" and "question" fields)
            question_text = question.get("question") or question.get("text", "")
            
            if image_ref not in question_text:
                # Prepend image reference to question text
                new_text = f"{image_ref}\n\n{question_text}"
                
                # Update the correct field
                if "question" in question:
                    question["question"] = new_text
                else:
                    question["text"] = new_text
                
                updated_count += 1
                print(f"   ‚úì Q{q_num_str}: Injected question diagram")
    
    return questions, updated_count


def inject_choice_diagrams(questions: List[Dict], mapping: Dict) -> tuple[List[Dict], int]:
    """
    Inject choice diagram references.
    Adds choiceImage field and updates options to simple letter labels.
    """
    updated_count = 0
    question_map = mapping.get("questions", {})
    
    for question in questions:
        q_num_str = extract_question_number(question)
        
        if q_num_str in question_map:
            web_path = question_map[q_num_str]["web_path"]
            
            # Add choiceImage field
            question["choiceImage"] = web_path
            
            # Update options to simple letter labels
            # Web app will display these as buttons while showing the choiceImage
            if isinstance(question.get("options"), list):
                num_options = len(question["options"])
                question["options"] = [
                    f"{chr(97 + i)})" for i in range(num_options)
                ]
            elif isinstance(question.get("options"), dict):
                question["options"] = {
                    key: f"{key})" for key in question["options"].keys()
                }
            
            updated_count += 1
            print(f"   ‚úì Q{q_num_str}: Injected choice diagram")
    
    return questions, updated_count


def inject_fill_in_blanks(questions: List[Dict], mapping: Dict) -> tuple[List[Dict], int]:
    """
    Inject fill-in-the-blank composite images.
    Adds compositeImage field and updates options to simple letter labels.
    These images contain both question and choices together.
    """
    updated_count = 0
    question_map = mapping.get("questions", {})
    
    for question in questions:
        q_num_str = extract_question_number(question)
        
        if q_num_str in question_map:
            web_path = question_map[q_num_str]["web_path"]
            
            # Add compositeImage field (full question + choices)
            question["compositeImage"] = web_path
            
            # Update options to simple letter labels
            # Web app will only show the compositeImage and choice buttons
            if isinstance(question.get("options"), list):
                num_options = len(question["options"])
                question["options"] = [
                    f"{chr(97 + i)})" for i in range(num_options)
                ]
            elif isinstance(question.get("options"), dict):
                question["options"] = {
                    key: f"{key})" for key in question["options"].keys()
                }
            
            # Optionally replace question text with a placeholder
            # (since the composite image shows everything)
            # Keeping original text for searchability
            
            updated_count += 1
            print(f"   ‚úì Q{q_num_str}: Injected composite image")
    
    return questions, updated_count


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Inject all visual content types into webapp JSON"
    )
    parser.add_argument(
        "--input",
        type=Path,
        required=True,
        help="Path to webapp_questions_{year}.json"
    )
    parser.add_argument(
        "--mapping",
        type=Path,
        required=True,
        help="Path to visual_content_mapping.json (from validate_visual_content.py)"
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Output path (default: overwrites input file)"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes"
    )
    
    args = parser.parse_args()
    
    # Set default output
    if not args.output:
        args.output = args.input
    
    # Load input JSON
    if not args.input.exists():
        print(f"‚ùå Error: Input file not found: {args.input}")
        return
    
    with open(args.input, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    questions = data if isinstance(data, list) else data.get("questions", [])
    print(f"üìÑ Loaded {len(questions)} questions from {args.input}")
    
    # Load mapping
    if not args.mapping.exists():
        print(f"‚ùå Error: Mapping file not found: {args.mapping}")
        return
    
    with open(args.mapping, 'r', encoding='utf-8') as f:
        mapping_data = json.load(f)
    
    print(f"üìÑ Loaded mapping for year {mapping_data['year']}")
    print(f"   Total images: {mapping_data['summary']['total_images']}")
    print()
    
    if args.dry_run:
        print("üîç DRY RUN MODE - No changes will be made\n")
    
    # Track totals
    total_updated = 0
    
    # 1. Inject question diagrams
    if "question_diagrams" in mapping_data["mappings"]:
        print("üìù Injecting question diagrams...")
        q_mapping = mapping_data["mappings"]["question_diagrams"]
        questions, count = inject_question_diagrams(questions, q_mapping)
        total_updated += count
        print(f"   Updated: {count} questions\n")
    
    # 2. Inject choice diagrams
    if "choices" in mapping_data["mappings"]:
        print("üìù Injecting choice diagrams...")
        c_mapping = mapping_data["mappings"]["choices"]
        questions, count = inject_choice_diagrams(questions, c_mapping)
        total_updated += count
        print(f"   Updated: {count} questions\n")
    
    # 3. Inject fill-in-the-blanks
    if "fill_in_the_blanks" in mapping_data["mappings"]:
        print("üìù Injecting fill-in-the-blank composites...")
        f_mapping = mapping_data["mappings"]["fill_in_the_blanks"]
        questions, count = inject_fill_in_blanks(questions, f_mapping)
        total_updated += count
        print(f"   Updated: {count} questions\n")
    
    # Update data structure
    if isinstance(data, list):
        data = questions
    else:
        data["questions"] = questions
    
    if args.dry_run:
        print(f"üîç Dry run complete. Would have updated {total_updated} questions.")
        return
    
    # Save output
    args.output.parent.mkdir(parents=True, exist_ok=True)
    with open(args.output, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    
    print("=" * 80)
    print("‚úÖ INJECTION COMPLETE")
    print("=" * 80)
    print(f"Total questions updated: {total_updated}")
    print(f"Output saved to: {args.output}")
    print()
    
    # Breakdown
    print("Breakdown by category:")
    for cat_name, cat_data in mapping_data["mappings"].items():
        count = len(cat_data["questions"])
        desc = cat_data["description"]
        print(f"  ‚Ä¢ {cat_name}: {count} questions ({desc})")
    
    print()
    print("‚ö†Ô∏è  NEXT STEPS:")
    print("1. Copy images to web app directory:")
    print("   data/{category}/ ‚Üí philnits/public/Files/{category}/")
    print("2. Validate with: python src/validate_schema.py --input output/webapp_questions_2025.json")
    print("3. Test in Next.js web app")


if __name__ == "__main__":
    main()
